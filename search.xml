<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决H5 键盘兼容性问题</title>
      <link href="/post/792c856b/"/>
      <url>/post/792c856b/</url>
      
        <content type="html"><![CDATA[<p>ios和安卓设备在唤起和收起键盘时会展现不同的效果,利用Element.scrollIntoViewIfNeeded(),将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域,可以解决唤起键盘时输入框表单被挡等问题.</p><p>分析详见:<span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/5c6d1c8b6fb9a049de6df441"  target="_blank" rel="noopener">https://juejin.im/post/5c6d1c8b6fb9a049de6df441</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ios设备设备下页面滚动问题</title>
      <link href="/post/3d040cbc/"/>
      <url>/post/3d040cbc/</url>
      
        <content type="html"><![CDATA[<p>如果你在safari浏览器和app内核浏览器中对需要滚动的元素设置如下样式时</p><pre><code>overflow|overflow-x|overflow-y:scroll;</code></pre><p>你会发现滚动区域的表现极其差劲,滚动在手指抬起时立即停止,不产生惯性滚动.</p><p>这时可以在以上样式的基础上通过添加<code>-webkit-overflow-scrolling: touch;</code>属性来实现ios下的惯性滚动效果.</p><pre><code>overflow:scroll;-webkit-overflow-scrolling: touch;</code></pre><p>分析详见: <span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/5c6ebc8af265da2dec623d51"  target="_blank" rel="noopener">https://juejin.im/post/5c6ebc8af265da2dec623d51</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript实现数组去重</title>
      <link href="/post/680dc6eb/"/>
      <url>/post/680dc6eb/</url>
      
        <content type="html"><![CDATA[        <h1 id="数组去重"   >          <a href="#数组去重" class="heading-link"><i class="fas fa-link"></i></a>数组去重</h1>              <h2 id="利用ES6-Set去重（ES6中最常用）"   >          <a href="#利用ES6-Set去重（ES6中最常用）" class="heading-link"><i class="fas fa-link"></i></a>利用ES6 Set去重（ES6中最常用）</h2>      <pre><code>function unique (arr) {    return Array.from(new Set(arr))}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {}, {}]</code></pre><p>不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“{}”空对象，后面的高阶方法会添加去掉重复“{}”的方法。</p><a id="more"></a>        <h2 id="利用for嵌套for，然后splice去重（ES5中最常用）"   >          <a href="#利用for嵌套for，然后splice去重（ES5中最常用）" class="heading-link"><i class="fas fa-link"></i></a>利用for嵌套for，然后splice去重（ES5中最常用）</h2>      <pre><code>function unique(arr){                for(var i=0; i&lt;arr.length; i++){        for(var j=i+1; j&lt;arr.length; j++){            if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个                arr.splice(j,1);                j--;            }        }    }    return arr;}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, {…}, {…}]     //NaN和{}没有去重，两个null直接消失了</code></pre>        <h2 id="利用indexOf去重"   >          <a href="#利用indexOf去重" class="heading-link"><i class="fas fa-link"></i></a>利用indexOf去重</h2>      <pre><code>function unique(arr) {    if (!Array.isArray(arr)) {        console.log(&apos;type error!&apos;)        return    }    var array = [];    for (var i = 0; i &lt; arr.length; i++) {        if (array .indexOf(arr[i]) === -1) {            array .push(arr[i])        }    }    return array;}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]  //NaN、{}没有去重</code></pre><p>新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</p>        <h2 id="利用sort"   >          <a href="#利用sort" class="heading-link"><i class="fas fa-link"></i></a>利用sort()</h2>      <pre><code>function unique(arr) {    if (!Array.isArray(arr)) {        console.log(&apos;type error!&apos;)        return;    }    arr = arr.sort()    var arrry= [arr[0]];    for (var i = 1; i &lt; arr.length; i++) {        if (arr[i] !== arr[i-1]) {            arrry.push(arr[i]);        }    }    return arrry;}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, {…}, {…}, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、{}没有去重</code></pre><p>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</p>        <h2 id="利用对象的属性不能相同的特点进行去重"   >          <a href="#利用对象的属性不能相同的特点进行去重" class="heading-link"><i class="fas fa-link"></i></a>利用对象的属性不能相同的特点进行去重</h2>      <pre><code>function unique(arr) {    if (!Array.isArray(arr)) {        console.log(&apos;type error!&apos;)        return    }    var arrry= [];    var  obj = {};    for (var i = 0; i &lt; arr.length; i++) {        if (!obj[arr[i]]) {            arrry.push(arr[i])            obj[arr[i]] = 1        } else {            obj[arr[i]]++        }    }    return arrry;}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))//[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, {…}]    //两个true直接去掉了，NaN和{}去重</code></pre>        <h2 id="利用includes"   >          <a href="#利用includes" class="heading-link"><i class="fas fa-link"></i></a>利用includes</h2>      <pre><code>function unique(arr) {    if (!Array.isArray(arr)) {        console.log(&apos;type error!&apos;)        return    }    var array =[];    for(var i = 0; i &lt; arr.length; i++) {            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值                    array.push(arr[i]);            }    }    return array}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]     //{}没有去重</code></pre>        <h2 id="利用hasOwnProperty"   >          <a href="#利用hasOwnProperty" class="heading-link"><i class="fas fa-link"></i></a>利用hasOwnProperty</h2>      <pre><code>function unique(arr) {    var obj = {};    return arr.filter(function(item, index, arr){        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)    })}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr));//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}]   //所有的都去重了</code></pre><p>利用hasOwnProperty 判断是否存在对象属性</p>        <h2 id="利用filter"   >          <a href="#利用filter" class="heading-link"><i class="fas fa-link"></i></a>利用filter</h2>      <pre><code>function unique(arr) {    return arr.filter(function(item, index, arr) {        //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素        return arr.indexOf(item, 0) === index;    });}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]</code></pre>        <h2 id="利用递归去重"   >          <a href="#利用递归去重" class="heading-link"><i class="fas fa-link"></i></a>利用递归去重</h2>      <pre><code>function unique(arr) {    var array= arr;    var len = array.length;    array.sort(function(a,b){   //排序后更加方便去重        return a - b;    })    function loop(index){        if(index &gt;= 1){            if(array[index] === array[index-1]){                array.splice(index,1);            }            loop(index - 1);    //递归loop，然后数组去重        }    }    loop(len-1);    return array;}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, {…}, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, undefined]</code></pre>        <h2 id="利用Map数据结构去重"   >          <a href="#利用Map数据结构去重" class="heading-link"><i class="fas fa-link"></i></a>利用Map数据结构去重</h2>      <pre><code>function arrayNonRepeatfy(arr) {    let map = new Map();    let array = new Array();  // 数组用于返回结果    for (let i = 0; i &lt; arr.length; i++) {        if(map .has(arr[i])) {  // 如果有该key值        map .set(arr[i], true);         } else {         map .set(arr[i], false);   // 如果没有该key值        array .push(arr[i]);        }    }     return array ;}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr))//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, {…}, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, undefined]</code></pre>        <h2 id="利用reduce-includes"   >          <a href="#利用reduce-includes" class="heading-link"><i class="fas fa-link"></i></a>利用reduce+includes</h2>      <pre><code>function unique(arr){    return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);}var arr = [1,1,&apos;true&apos;,&apos;true&apos;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&apos;NaN&apos;, 0, 0, &apos;a&apos;, &apos;a&apos;,{},{}];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]</code></pre>        <h2 id="…new-Set-arr"   >          <a href="#…new-Set-arr" class="heading-link"><i class="fas fa-link"></i></a>[…new Set(arr)]</h2>      <pre><code>[...new Set(arr)] </code></pre>        <h2 id="参考文章"   >          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a>参考文章</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://segmentfault.com/a/1190000016418021"  target="_blank" rel="noopener" title="Markdown">JavaScript数组去重（12种方法，史上最全）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何避免出现“cannot read property of undefined”错误</title>
      <link href="/post/c9529d69/"/>
      <url>/post/c9529d69/</url>
      
        <content type="html"><![CDATA[        <h1 id="如何避免出现“cannot-read-property-of-undefined”错误"   >          <a href="#如何避免出现“cannot-read-property-of-undefined”错误" class="heading-link"><i class="fas fa-link"></i></a>如何避免出现“cannot read property of undefined”错误</h1>      <p>开发时经常会出现某对象属性为undefined,而继续获取下一层属性时导致报错,有以下方案可以避免错误的发生</p>        <h2 id="使用方法库"   >          <a href="#使用方法库" class="heading-link"><i class="fas fa-link"></i></a>使用方法库</h2>      <p>lodash中的_.get或者Ramda 里的 R.path方法;<br>但有时只是想单纯避免出现这个错误,而不想引入整合类库造成不必要的浪费.</p><a id="more"></a>        <h2 id="使用-amp-amp-“短路”"   >          <a href="#使用-amp-amp-“短路”" class="heading-link"><i class="fas fa-link"></i></a>使用 &amp;&amp; “短路”</h2>      <p>使用<code>&amp;&amp;</code>符号,例如:</p><pre><code>meals.breakfast &amp;&amp; meals.breakfast.protein</code></pre><p>但是会导致获取属性值时有重复的代码,比如前面的<code>meals.breakfast</code></p>        <h2 id="使用“或单元”"   >          <a href="#使用“或单元”" class="heading-link"><i class="fas fa-link"></i></a>使用“或单元”</h2>      <p>同上是一种特殊的代码结构,在每个<code>||</code>后都有一个默认值防止报错,例如:</p><pre><code>((favorites.reading||{}).books||[])[0],</code></pre><p>然而此方案代码可读性较差;</p>        <h2 id="使用try-catch"   >          <a href="#使用try-catch" class="heading-link"><i class="fas fa-link"></i></a>使用try/catch</h2>      <p>此方案检查单个属性可用,多个属性写在里面无法排查错误位置;</p>        <h2 id="未来展望"   >          <a href="#未来展望" class="heading-link"><i class="fas fa-link"></i></a>未来展望</h2>      <p>可选链式调用:TC39 提案中的一个功能,例如</p><pre><code>favorites?.video?.shows[0];</code></pre>        <h2 id="参考文章"   >          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a>参考文章</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://juejin.im/post/5c810170e51d450a453fb48e"  target="_blank" rel="noopener" title="Markdown">避免那些可恶的 “cannot read property of undefined” 错误</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层叠上下文</title>
      <link href="/post/9daba997/"/>
      <url>/post/9daba997/</url>
      
        <content type="html"><![CDATA[<p>“层叠上下文”描述了DOM元素在页面中形成的一种堆叠关系,它的一些规则决定了元素在页面z轴展现的先后顺序,这也解释了z-index值很高的元素会被一些值比较低的元素遮挡等等现象.<br>某个dom元素触发“层叠上下文”是有以下条件的:</p><p>z-index 值不为 “auto”的 绝对/相对/绝对定位;<br>flex 项(父元素 display 为 flex|inline-flex)，需要配合z-index;<br>opacity 属性值小于 1 的元素;<br>transform 属性值不为 “none”的元素;<br>mix-blend-mode 属性值不为 “normal”的元素;<br>perspective值不为“none”的元素;<br>filter与层叠上下文;</p><a id="more"></a><p>在相同层叠上下文的情况下,元素之间会按”层叠水平”的优先级排序(以下从低至高):<br>background/border;<br>负值z-index;<br>block块状水平盒子;<br>float浮动盒子;<br>inline\inline-block水平盒子;<br>z-index:0\auto;<br>正值z-index;<br>如果是在不同的层叠上下文中，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下这个两个元素所在的局部层叠上下文的层叠水平</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新建一个npm配置文件package.json</title>
      <link href="/post/7f3647cb/"/>
      <url>/post/7f3647cb/</url>
      
        <content type="html"><![CDATA[<p>如果需要在项目中使用npm的一些功能,一般有需要在项目里面添加一个<code>package.json</code>文件.它描述了项目目需要使用的npm模块,项目的基本信息等.</p><p>该文件可以手动添加,更方便一点的方式是在控制台使用如下命令:</p><pre><code>npm init</code></pre><a id="more"></a><p>执行此命令后,会有一系列回答步骤,回答完毕后会在<code>package.json</code>中生成如下基本配置</p><pre><code>{    /* 项目名称 */    &quot;name&quot;: &quot;new-npm&quot;,    /* 版本号 */    &quot;version&quot;: &quot;1.0.0&quot;,    /* 项目描述 */    &quot;description&quot;: &quot;&quot;,    /*         入口文件,如果改项目作为模块使用,其他        项目依赖此项目时返回此路径中的文件    */    &quot;main&quot;: &quot;index.js&quot;,    &quot;scripts&quot;: {        &quot;test&quot;: &quot;aaa&quot;    },    /* 存放代码的地方 */    &quot;repository&quot;: {        &quot;type&quot;: &quot;git&quot;,        &quot;url&quot;: &quot;https://github.com/DiamondsMe/study.git&quot;    },    /* 关键字,便于用户搜索到此模块 */    &quot;keywords&quot;: [        &quot;adfasf&quot;    ],    /* 作者 */    &quot;author&quot;: &quot;fasfd&quot;,    /* 项目许可证 */    &quot;license&quot;: &quot;ISC&quot;}</code></pre>        <h2 id="参考文章"   >          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a>参考文章</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/bydzhangxiaowei/p/8729210.html"  target="_blank" rel="noopener" title="Markdown">package.json说明 by 张小伟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/whkl-m/p/6617540.html"  target="_blank" rel="noopener" title="Markdown">对package.json的理解和学习</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
